# в чем приемущества 
1. конкурентного вч-й
>лучше утилезируется процесорное время\
>как правило комбинация параллельных и асинхронных\


2. параллельного вч-й
>нет оверхеда на синхронизацию\
>лучше утилезируется процесорное время\

3. микросервисных вч-й
>Децентрализованное управление данными\
>специализированные СУБД\
>Индивидуальные требования латенси надежность\
>Распределенные транзакции невероятно сложны\

4. асинхронные вч-й
> вроде подразумевает возврат обещания\
>временна́я задержка и взаимодействие с пользователем\

5. конвеерных вч-й
>подпрограмм так, чтобы выход одной из них был входом для другой. Это называется конвейером (pipeline)\





# массивы/слайсы
1. при удалении одних элементов массива и наполнии новыми вы ушли за лимиты памяти\
> можно удалять (заменой/копировать и срезать/заменить и отрезать конец без сохранения порядка)\
>
>
>
2. была произведена запись в слайс, но она не сохранилась
> append возвращает новый слайс с другим len и возможно cap\


3. после отработки программы данные в файл записались не полностью 

4. после выполнения функции данные исчезают 

5. Данные записываются, но удаляются

6. Данные не записываются, но удаляются



# как гарантировать
1. скорость вч-й
2. синхронность вч-й
3. параллельность вч-й 
> нужно разделить данные на эксклюзивные части

4. безопасность данных
> гарантировать эксклюзивное владение данными патоку, или синхранизировать доступ

5. отказоустойчивость
>  

# когда нужно пустить под нож
1. синхронизацию вч-й
> когда вычесления не зависимы и работают с эксклюзивными данными

2. безопасность данных
> если данные эксклюзивны ?

3. результат вч-й
> если отмена миссии ?

4. параллельность вч-й
> когда скорость ответа не важна и при этом утилизируется проц. время без этого
> еще когда требуется много синхронизации и нет возможности для каждого потока выделить эксклюзивные данные

5. скорость вч-й
> когда это не является узким местом ?


# for
>Базовый for цикл состоит из трех компонентов, разделенных точкой с запятой:\
>1 оператор init: выполняется перед первой итерацией\
>2 выражение условия: оценивается перед каждой итерацией\
>3 оператор post: выполняется в конце каждой итерации\
>Оператор init часто представляет собой короткое объявление переменной, и объявленные там переменные видны только в области действия оператора for.\

1. как реализовать FIFO циклом
> кольцевой буфер?
2. как итерироваться в for по функции
```go
func foo() chan string {
    ch := make(chan string)
     go func() {
        for i := 0; i < 10; i++ {
            ch <- strconv.Itoa(i)
        }
        close(ch)
     }()
    return ch
}

func main() {
    for i := range foo() {
        fmt.Println(i)
    }
}
```
3. в чем особенность области видимости цикла for
>Go 1.22 изменяет правила определения области видимости для переменных в циклах for. \
>Раньше переменные цикла имели область видимости для всего цикла. \
>Теперь каждая итерация получает свою собственную область видимости.\
>выражение range создаёт копию самого массива/слайса\

4. как выйти из бесконечного цикла без break
5. цикл итерирующийся по массиву стал бесконечным циклом