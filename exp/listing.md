# в чем приемущества

1. конкурентного вч-й

   > Конкурентность позволяет увеличить скорость обработки данных
   > как правило комбинация параллельных и асинхронных\

2. параллельного вч-й

   > нет оверхеда на синхронизацию\
   > лучше утилезируется процесорное время\

3. микросервисных вч-й

   > Децентрализованное управление данными\
   > специализированные СУБД\
   > Индивидуальные требования латенси надежность\

4. асинхронные вч-й

   > вроде подразумевает возврат обещания \ Асинхронная — когда сообщение не предполагает моментальный ответ.
   > асинхронные операции могут выполнять несколько задач одновременно в одном потоке
   > лучше утилезируется процесорное время\

5. конвеерных вч-й
   > Организация (программ\горутин\сервисов) так, чтобы выход одной из них был входом для другой. Это называется конвейером (pipeline)\

# массивы/слайсы

1. при удалении одних элементов массива и наполнии новыми вы ушли за лимиты памяти\

   > Смотря что за лимит памяти
   > можно удалять (заменой/копировать и срезать/заменить и отрезать конец без сохранения порядка)\
   > при этом память не освобождается или не сразу.
   > Либо перезаписывать значения которые хотим удалить новыми
   > Либо создать новый наполнить только нужными значениями

2. была произведена запись в слайс, но она не сохранилась

   > append возвращает новый слайс с другим len и возможно cap\

3. после отработки программы данные в файл записались не полностью
   > Пологаю тут про завершение программы
   > по сигналу добисать в файл \ закрыть файл и завершить программу
4. после выполнения функции данные исчезают
   > наверное ананимная? область видимости
5. Данные записываются, но удаляются
6. Данные не записываются, но удаляются
   > ???

# как гарантировать

1. скорость вч-й

   > хз ???

2. синхронность вч-й

   > пологаю - Синхронная коммуникация — это когда получатель сразу отвечает на сообщение.

3. параллельность вч-й

   > нужно разделить данные на эксклюзивные части

4. безопасность данных

   > гарантировать эксклюзивное владение данными патоку, или синхранизировать доступ

5. отказоустойчивость
   > репликация(дубрировать) сервисы ???

# когда нужно пустить под нож

1. синхронизацию вч-й

   > когда вычесления не зависимы и работают с эксклюзивными данными

2. безопасность данных

   > если данные эксклюзивны ???

3. результат вч-й

   > если отмена миссии ???

4. параллельность вч-й

   > когда скорость ответа не важна и при этом утилизируется проц. время без этого
   > еще когда требуется много синхронизации и нет возможности для каждого потока выделить эксклюзивные данные

5. скорость вч-й
   > когда это не является узким местом ???

# Panic

# Переменные

1. переменная созданная в init() глобальная?

   > Переменная, созданная в функции **`init()`**, не является глобальной. Функция **`init()`** \
   > предназначена для инициализации пакета и вызывается автоматически перед >выполнением функции **`main()`** в Go программе.\
   > Если вы хотите создать глобальную переменную в пакете, ее следует определить за пределами функции **`init()`**\

2. Когда можно, когда нельзя использовать глобальные переменные?
   > **Когда можно использовать глобальные переменные:**

> 1.  **Константы:** которые используются во всем пакете.
> 2.  **Настройки приложения:** Глобальные переменные могут использоваться для хранения настроек приложения, таких как конфигурационные параметры.
> 3.  **Реализация синглтонов:** Глобальные переменные могут использоваться для реализации синглтонов - классов, которые должны существовать в единственном экземпляре.
> 4.  **Кэши:** Глобальные переменные могут использоваться для хранения кэша или других ресурсов, к которым нужен доступ из разных частей программы.

> **Когда следует избегать использования глобальных переменных:**

> 1.  **Побочные эффекты:** Использование глобальных переменных может привести к неожиданным побочным эффектам и делает код менее предсказуемым.
> 2.  **Многопоточность:** Глобальные переменные могут быть проблематичными при работе в многопоточной среде из-за конкурентного доступа к ним из разных потоков.
> 3.  **Понимаемость кода:** Использование глобальных переменных может усложнить понимание кода, особенно если они используются в разных местах программы.
> 4.  **Тестирование:** Глобальные переменные могут затруднить тестирование, поскольку они могут оказывать влияние на поведение других частей программы,
>     что делает тестирование более сложным.

3. как создать свою область видимости?

   > **Функции:** Объявление переменных внутри функций создает локальную область видимости для этих переменных.
   > **Анонимные функции:** Вы можете создать анонимную функцию внутри другой функции
   > **Видимость внутри пакета:** Имена, объявленные внутри пакета, доступны во всех файлах этого пакета.

   > **Блочные области видимости:** В Go нет блочной области видимости, но вы можете использовать вложенные блоки
   > **`{}`** для создания локальной области видимости внутри функций

```go
  func main() {
      x := 10 // локальная переменная для функции main
      fmt.Println(x)

      {
          // y - локальная переменная внутри блока
          y := 20
          fmt.Println(y)
      }
      // fmt.Println(y) // Ошибка: y не определен в этой области видимости
  }
```



4. как создать глобальную переменную только для 1 пакета

# for
>Базовый for цикл состоит из трех компонентов, разделенных точкой с запятой:\
>1 оператор init: выполняется перед первой итерацией\
>2 выражение условия: оценивается перед каждой итерацией\
>3 оператор post: выполняется в конце каждой итерации\
>Оператор init часто представляет собой короткое объявление переменной, и объявленные там переменные видны только в области действия оператора for.\

1. как реализовать FIFO циклом
> кольцевой буфер?
2. как итерироваться в for по функции
```go
func foo() chan string {
  ch := make(chan string)
   go func() {
      for i := 0; i < 10; i++ {
          ch <- strconv.Itoa(i)
      }
      close(ch)
   }()
  return ch
}

func main() {
  for i := range foo() {
      fmt.Println(i)
  }
}
````

3. в чем особенность области видимости цикла for

   > Go 1.22 изменяет правила определения области видимости для переменных в циклах for. \
   > Раньше переменные цикла имели область видимости для всего цикла. \
   > Теперь каждая итерация получает свою собственную область видимости.\
   > выражение range создаёт копию самого массива/слайса\

4. как выйти из бесконечного цикла без break
   > Оператор goto в Go предоставляет возможность передвигаться внутри функции к метке,
   > обозначенной ключевым словом label. Это позволяет перепрыгивать через части кода,
   > используя явное указание места назначения в программе.

```go

i := 0
	for {
		i++
		if i == 6 {
			goto endloop
		}
	}
endloop:
	fmt.Println("end")

```

5. цикл итерирующийся по массиву стал бесконечным циклом
