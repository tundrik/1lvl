# в чем приемущества

1. конкурентного вч-й
   > Конкурентные вычисления — это форма вычислений, когда несколько инструкций выполняются, пересекаясь, \
   > в течение одного временного периода. Например есть 2 > инструкции, которые нужно выполнить: А и B. \
   > При выполнении инструкций конкурентно ядро процессора вычисляет инструкцию A, при ожидающей B.\
   > Конкурентность позволяет утелизировать CPU\
   > Конкурентность позволяет увеличить пропускную способность обработки данных\
   > как правило комбинация параллельных и асинхронных (CPU\IO) операций

2. параллельного вч-й
   > В моем понимании параллельно это на разных ядрах не зависимо\
   > И предпологает CPU задачи\
   > лучше утилезируется процесорное время\
   > Как правило реализуется в комбинации с асинхронными - данные нужно от куда то брать и куда то отдавать

3. микросервисных вч-й
   > Можно применить индивидуальные требования (скорость\надежность) а также к железу\

4. асинхронные вч-й
   > вроде подразумевает возврат обещания \ Асинхронная — когда сообщение не предполагает моментальный ответ.\
   > Позволяет отдать процесорное время для других задач тем самым позволяет утелизировать CPU\
   > несколько горутин (G) могут выполнять несколько сетевых ожиданий в одном потоке не блокируя (M)\
   > если (G) блокирует (M) (M) отсоединяет (P) с очередью горутин и этот (P) подхватывает другой (M)\

5. конвеерных вч-й

   > В конвеере мы делим обработку данных на этапы\
   > Каждый этам можем масштабировать независимо от других этапов\
   > например 1 ко многим \ многие к 1 \ 1 ко многим многие к 1\
   > Как правило подразумевает использование каналов в go для коммуникации горутин\
   > Как правило подразумевает использование брокера сообщений для коммуникации между сервисами

6. последовательного вч-й
   >Поскольку при последавательном вычеслении выполнение следующей задачи начинается только после завершения предыдущей.\
   >Нам не требуется завершать\отменять задачи при неудаче в одной из них\

7. как влияет эффект масштаба на вычисления
   >Если появляется эффект масштаба и с вычеслениями не справляется 1 машина\
   >Нужно масштабировать на несколько машин \
   >Соответственно разбивать вычесления на этапы и мутить конвеер\

# как гарантировать

1. скорость вч-й
   > хз ??? Мы пожем ограничить вычесление по дедлайну\
   > хз ??? Гарантировать время выполнения как для систем реального времени мы не можем при использовании GC

2. синхронность вч-й
   > Вычеслять последовательно - при синхронном программировании выполнение следующей задачи начинается только после завершения предыдущей.\
   > Например мы можем использовать атомик для последовательного сложения или прибавления\
   > наверное тут синхронизацию ??? .\
   > gw, mutex, chan

3. параллельность вч-й
   > Ограничить количество вычеслений в один момент времени равным переменной GOMAXPROCS\
   > нужно разделить данные на эксклюзивные части\
   > не допускать пересечения данных в кеш линиях ядер - это может убить всю пользу от параллельности если будут промахи кеша\

4. безопасность данных

   > гарантировать эксклюзивное владение данными патоку, или синхранизировать доступ gw, mutex, chan

5. отказоустойчивость
   > Использовать распределенного брокера с записью на диск, журналами и т.д между микросервисами + (реплицировать сервисы)

# когда нужно пустить под нож

1. синхронизацию вч-й

   > когда вычесления не зависимы и работают с эксклюзивными данными они не требуют синхранизации

2. безопасность данных

   > если данные эксклюзивны для одного потока ???

3. результат вч-й

   > если отмена миссии ???

4. параллельность вч-й
   > когда скорость ответа не важна и при этом утилизируется проц. время без этого\
   > Когда разпараллеливание вычесления не дает ускорения.\
   > Это может быть из за проблемы когерентности кеша, а выравнивать по линии кеша не выгодно\


5. скорость вч-й
   > когда это не является узким местом в общей системе ???

6. количество живых горутин
   > Если определенное количество горутин утилизирует процесорное время
   > то больше не имеет смысла так как будут толпится в очереди

# массивы/слайсы

1. при удалении одних элементов массива и наполнии новыми вы ушли за лимиты памяти
   > Судя по словам - массив и удалении\наполнение новыми какойто подвох)\
   > Если это массив вероятно это будет замена старых значений новыми\

   > Если динамический массив (слайс)\
   > есть способы удалять элементы\
   > 1) Без сохранения порядка заменить не нужные значения значениями с хвоста и отрезать хвост (при этом память освободится не сразу) \
   > и возможно (не влезем в лимит памяти)\
   > 2) Создать новый слайс заполнить его только нужными из первого и наполнить новыми (но не влезем в лимит памяти) пока первый не соберет GC


2. была произведена запись в слайс, но она не сохранилась

   > append возвращает новый слайс с другим len и если cap небыло достаточно то новая аллокация

3. после отработки программы данные в файл записались не полностью

   > Пологаю тут про завершение программы ???
   > по сигналу дописать в файл \ закрыть файл и завершить программу
   > Способы ctx  закрытие chan

4. после выполнения функции данные исчезают
   > наверное ананимная? область видимости ???
   > функция должна возвращать 

5. Данные записываются, но удаляются
6. Данные не записываются, но удаляются
   > вероятно записываются но мы не видим их при итерации ???

# Panic
>Паника — это встроенная функция, которая останавливает обычный поток управления и начинает паниковать . 
>Когда функция F вызывает панику, выполнение F прекращается, любые отложенные функции в F выполняются нормально, 
>а затем F возвращается к вызывающей стороне. Для >вызывающего абонента F тогда ведет себя как призыв к панике. 
>Процесс продолжается вверх по стеку до тех пор, пока все функции в текущей горутине не вернутся, после чего программа выходит из строя. 
>Панику можно вызвать, >непосредственно вызвав панику. Они также могут быть вызваны ошибками времени выполнения, такими как доступ к массиву за пределами границ.

>Recover — это встроенная функция, которая восстанавливает контроль над паникующей горутиной. 
>Восстановление полезно только внутри отложенных функций. Во время >нормального выполнения вызов восстановления вернет ноль 
>и не будет иметь никакого другого эффекта. Если текущая горутина находится в состоянии паники, вызов 
>.восстановления захватит значение, присвоенное панике, и возобновит нормальное выполнение.
```go
func main() {
    f()
    fmt.Println("Returned normally from f.")
}

func f() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered in f", r)
        }
    }()
    fmt.Println("Calling g.")
    g(0)
    fmt.Println("Returned normally from g.")
}

func g(i int) {
    if i > 3 {
        fmt.Println("Panicking!")
        panic(fmt.Sprintf("%v", i))
    }
    defer fmt.Println("Defer in g", i)
    fmt.Println("Printing in g", i)
    g(i + 1)
}
```

2. panic conversion
   > panic conversion - это ситуация, когда тип данных не может быть преобразован в ожидаемый тип во время выполнения программы.
   > Это может произойти, например, когда происходит попытка преобразовать значение интерфейса в конкретный тип данных, которое несовместимо с фактическим типом значения.

3. panic nil pointer
```go
func main() {
	var p *Point
	fmt.Println(p.Abs())
}

```

# Переменные

1. переменная созданная в init() глобальная?

   > Переменная, созданная в функции **`init()`**, не является глобальной. Функция **`init()`** \
   > предназначена для инициализации пакета и вызывается автоматически перед >выполнением функции **`main()`** в Go программе.\
   > Если вы хотите создать глобальную переменную в пакете, ее следует определить за пределами функции **`init()`**\

2. Когда можно, когда нельзя использовать глобальные переменные?
   > **Когда можно использовать глобальные переменные:**

> 1.  **Константы:** которые используются во всем пакете.
> 2.  **Настройки приложения:** Глобальные переменные могут использоваться для хранения настроек приложения, таких как конфигурационные параметры.
> 3.  **Реализация синглтонов:** Глобальные переменные могут использоваться для реализации синглтонов - классов, которые должны существовать в единственном экземпляре.
> 4.  **Кэши:** Глобальные переменные могут использоваться для хранения кэша или других ресурсов, к которым нужен доступ из разных частей программы.

> **Когда следует избегать использования глобальных переменных:**

> 1.  **Побочные эффекты:** Использование глобальных переменных может привести к неожиданным побочным эффектам и делает код менее предсказуемым.
> 2.  **Многопоточность:** Глобальные переменные могут быть проблематичными при работе в многопоточной среде из-за конкурентного доступа к ним из разных потоков.
> 3.  **Понимаемость кода:** Использование глобальных переменных может усложнить понимание кода, особенно если они используются в разных местах программы.
> 4.  **Тестирование:** Глобальные переменные могут затруднить тестирование, поскольку они могут оказывать влияние на поведение других частей программы,
>     что делает тестирование более сложным.

3. как создать свою область видимости?
   > for, (switch ?? switch v := "v"; {} )
   > **Функции:** Объявление переменных внутри функций создает локальную область видимости для этих переменных.
   > **Анонимные функции:** Вы можете создать анонимную функцию внутри другой функции
   > **Видимость внутри пакета:** Имена, объявленные внутри пакета, доступны во всех файлах этого пакета.

   > **Блочные области видимости:** В Go нет блочной области видимости, но вы можете использовать вложенные блоки
   > **`{}`** для создания локальной области видимости внутри функций

```go
  func main() {
      x := 10 // локальная переменная для функции main
      fmt.Println(x)

      {
          // y - локальная переменная внутри блока
          y := 20
          fmt.Println(y)
      }
      // fmt.Println(y) // Ошибка: y не определен в этой области видимости
  }
```

4. как создать глобальную переменную только для 1 пакета
   > имена с маленькой буквы. Это распространяется на функции, методы, глобальные переменные, константы, поля в структуре

# for

> Базовый for цикл состоит из трех компонентов, разделенных точкой с запятой:\
> 1 оператор init: выполняется перед первой итерацией\
> 2 выражение условия: оценивается перед каждой итерацией\
> 3 оператор post: выполняется в конце каждой итерации\
> Оператор init часто представляет собой короткое объявление переменной, и объявленные там переменные видны только в области действия оператора for.\

1. как реализовать FIFO циклом
   > Сделать цикл в обратном порядке
   > если есть массив [1, 2, 3] делаем что-то для 3 потом 2 делее 1

2. как итерироваться в for по функции
   > Вариант 1 использовать канал

```go
func foo() chan string {
  ch := make(chan string)
   go func() {
      for i := 0; i < 10; i++ {
          ch <- strconv.Itoa(i)
      }
      close(ch)
   }()
  return ch
}

func main() {
  for i := range foo() {
      fmt.Println(i)
  }
}
```

> Вариант 2 использовать замыкание в функции которое возвращает условие bool

3. в чем особенность области видимости цикла for

   > Go 1.22 изменяет правила определения области видимости для переменных в циклах for. \
   > Раньше переменные цикла имели область видимости для всего цикла. \
   > Теперь каждая итерация получает свою собственную область видимости.\
   > выражение range создаёт копию самого массива/слайса\

4. как выйти из бесконечного цикла без break
   > Оператор goto в Go предоставляет возможность передвигаться внутри функции к метке,
   > обозначенной ключевым словом label. Это позволяет перепрыгивать через части кода,
   > используя явное указание места назначения в программе.

```go

i := 0
	for {
		i++
		if i == 6 {
			goto endloop
		}
	}
endloop:
	fmt.Println("end")

```

5. цикл итерирующийся по массиву стал бесконечным циклом
   > Условие для выхода из цикла не выполняется

```go

arr := []int{1, 2, 3, 4, 5}
	for i := 0; i < len(arr); i++ {
		if i == len(arr)-1 {
			i = 0
		}
	}
```
