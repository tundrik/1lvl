# в чем приемущества

1. конкурентного вч-й

   > Конкурентность позволяет увеличить скорость обработки данных\
   > как правило комбинация параллельных и асинхронных (CPU\IO)

2. параллельного вч-й

   > В моем понимании параллельно это на разных ядрах не зависимо\
   > И предпологает CPU задачи\
   > нет оверхеда на синхронизацию\
   > лучше утилезируется процесорное время\
   > Как правило реализуется в комбинации с асинхронными - данные нужно от куда то брать и куда то отдавать

3. микросервисных вч-й

   > Можно применить индивидуальные требования (скорость\надежность)\
   > Можно применить специализированные СУБД под каждый сервис

4. асинхронные вч-й

   > вроде подразумевает возврат обещания \ Асинхронная — когда сообщение не предполагает моментальный ответ.
   > асинхронные операции могут выполнять несколько ожиданий (IO) одновременно в одном потоке

5. конвеерных вч-й

   > Организация (горутин\сервисов) так, чтобы выход одной из них был входом для другой. Это называется конвейером (pipeline)\
   > Как правило подразумевает использование каналов в go для коммуникации горутин\
   > Как правило подразумевает использование брокера сообщений для коммуникации между сервисами\

6. последовательного вч-й
7. как влияет эффект масштаба на вычисления

# массивы/слайсы

1. при удалении одних элементов массива и наполнии новыми вы ушли за лимиты памяти\

   > Смотря что за лимит памяти
   > можно удалять (заменой/копировать и срезать/заменить и отрезать конец без сохранения порядка)\
   > при этом память не освобождается или не сразу.
   > Либо перезаписывать значения которые хотим удалить новыми
   > Либо создать новый наполнить только нужными значениями

2. была произведена запись в слайс, но она не сохранилась

   > append возвращает новый слайс с другим len и возможно cap\

3. после отработки программы данные в файл записались не полностью
   > Пологаю тут про завершение программы
   > по сигналу добисать в файл \ закрыть файл и завершить программу
4. после выполнения функции данные исчезают
   > наверное ананимная? область видимости
5. Данные записываются, но удаляются
6. Данные не записываются, но удаляются
   > ???

# как гарантировать

1. скорость вч-й

   > хз ???

2. синхронность вч-й

   > пологаю - Синхронная коммуникация — это когда получатель сразу отвечает на сообщение.

3. параллельность вч-й

   > нужно разделить данные на эксклюзивные части

4. безопасность данных

   > гарантировать эксклюзивное владение данными патоку, или синхранизировать доступ

5. отказоустойчивость
   > репликация(дубрировать) сервисы ???

# когда нужно пустить под нож

1. синхронизацию вч-й

   > когда вычесления не зависимы и работают с эксклюзивными данными они не требуют синхранизации

2. безопасность данных

   > если данные эксклюзивны для одного потока ???

3. результат вч-й

   > если отмена миссии ???

4. параллельность вч-й

   > 1) Когда разпараллеливание вычесления не дает ускорения.\
   > Это может быть из за проблемы когерентности кеша, а выравнивать по линии кеша не выгодно\
   > 2) когда скорость ответа не важна и при этом утилизируется проц. время без этого

5. скорость вч-й

   > когда это не является узким местом ???

6. количество живых горутин
   > Если определенное количество горутин утилизирует процесорное время
   > то больше не имеет смысла так как будут толпится в очереди

# Panic

1. panic conversion
   > panic conversion - это ситуация, когда тип данных не может быть преобразован в ожидаемый тип во время выполнения программы.
   > Это может произойти, например, когда происходит попытка преобразовать значение интерфейса в конкретный тип данных, которое несовместимо с фактическим типом значения.

# Переменные

1. переменная созданная в init() глобальная?

   > Переменная, созданная в функции **`init()`**, не является глобальной. Функция **`init()`** \
   > предназначена для инициализации пакета и вызывается автоматически перед >выполнением функции **`main()`** в Go программе.\
   > Если вы хотите создать глобальную переменную в пакете, ее следует определить за пределами функции **`init()`**\

2. Когда можно, когда нельзя использовать глобальные переменные?
   > **Когда можно использовать глобальные переменные:**

> 1.  **Константы:** которые используются во всем пакете.
> 2.  **Настройки приложения:** Глобальные переменные могут использоваться для хранения настроек приложения, таких как конфигурационные параметры.
> 3.  **Реализация синглтонов:** Глобальные переменные могут использоваться для реализации синглтонов - классов, которые должны существовать в единственном экземпляре.
> 4.  **Кэши:** Глобальные переменные могут использоваться для хранения кэша или других ресурсов, к которым нужен доступ из разных частей программы.

> **Когда следует избегать использования глобальных переменных:**

> 1.  **Побочные эффекты:** Использование глобальных переменных может привести к неожиданным побочным эффектам и делает код менее предсказуемым.
> 2.  **Многопоточность:** Глобальные переменные могут быть проблематичными при работе в многопоточной среде из-за конкурентного доступа к ним из разных потоков.
> 3.  **Понимаемость кода:** Использование глобальных переменных может усложнить понимание кода, особенно если они используются в разных местах программы.
> 4.  **Тестирование:** Глобальные переменные могут затруднить тестирование, поскольку они могут оказывать влияние на поведение других частей программы,
>     что делает тестирование более сложным.

3. как создать свою область видимости?

   > **Функции:** Объявление переменных внутри функций создает локальную область видимости для этих переменных.
   > **Анонимные функции:** Вы можете создать анонимную функцию внутри другой функции
   > **Видимость внутри пакета:** Имена, объявленные внутри пакета, доступны во всех файлах этого пакета.

   > **Блочные области видимости:** В Go нет блочной области видимости, но вы можете использовать вложенные блоки
   > **`{}`** для создания локальной области видимости внутри функций

```go
  func main() {
      x := 10 // локальная переменная для функции main
      fmt.Println(x)

      {
          // y - локальная переменная внутри блока
          y := 20
          fmt.Println(y)
      }
      // fmt.Println(y) // Ошибка: y не определен в этой области видимости
  }
```

4. как создать глобальную переменную только для 1 пакета
   > имена с маленькой буквы. Это распространяется на функции, методы, глобальные переменные, константы, поля в структуре

# for

> Базовый for цикл состоит из трех компонентов, разделенных точкой с запятой:\
> 1 оператор init: выполняется перед первой итерацией\
> 2 выражение условия: оценивается перед каждой итерацией\
> 3 оператор post: выполняется в конце каждой итерации\
> Оператор init часто представляет собой короткое объявление переменной, и объявленные там переменные видны только в области действия оператора for.\

1. как реализовать FIFO циклом

   > кольцевой буфер???

2. как итерироваться в for по функции
   > Вариант 1 использовать канал

```go
func foo() chan string {
  ch := make(chan string)
   go func() {
      for i := 0; i < 10; i++ {
          ch <- strconv.Itoa(i)
      }
      close(ch)
   }()
  return ch
}

func main() {
  for i := range foo() {
      fmt.Println(i)
  }
}
```

> Вариант 2 использовать замыкание в функции которое возвращает условие bool

3. в чем особенность области видимости цикла for

   > Go 1.22 изменяет правила определения области видимости для переменных в циклах for. \
   > Раньше переменные цикла имели область видимости для всего цикла. \
   > Теперь каждая итерация получает свою собственную область видимости.\
   > выражение range создаёт копию самого массива/слайса\

4. как выйти из бесконечного цикла без break
   > Оператор goto в Go предоставляет возможность передвигаться внутри функции к метке,
   > обозначенной ключевым словом label. Это позволяет перепрыгивать через части кода,
   > используя явное указание места назначения в программе.

```go

i := 0
	for {
		i++
		if i == 6 {
			goto endloop
		}
	}
endloop:
	fmt.Println("end")

```

5. цикл итерирующийся по массиву стал бесконечным циклом
   > Условие для выхода из цикла не выполняется

```go

arr := []int{1, 2, 3, 4, 5}
	for i := 0; i < len(arr); i++ {
		if i == len(arr)-1 {
			i = 0
		}
	}
```
