1. Какой самый эффективный способ конкатенации строк?

> Ответ:\
>`strings.Builder` или `bytes.Buffer` если нужно повторно использовать буфер или манипулировать байтами.


2. Что такое интерфейсы, как они применяются в Go?
>Ответ:\
>В Go интерфейс — это тип, определяющий набор сигнатур методов. 
>Говорят, что любой тип, реализующий все методы, определенные в интерфейсе, удовлетворяет интерфейсу. 
>Это позволяет вам писать универсальный код, который можно использовать с любым типом, удовлетворяющим интерфейсу.

3. Чем отличаются RWMutex от Mutex?
>Ответ:\
>Размер RWMutex на шестнадцать байт больше, чем Mutex)\
>Mutex один замок, один ключ (CAS 1|0).\
>RWMutex включает в себя Mutex.\
>RWMutex содержит счетчик читающих.\
>RWMutex выполняет больше работы.

4. Чем отличаются буферизированные и небуферизированные каналы?
>Ответ:\
>Небуферизованный канал с нулевой пропускной способностью, 
>и связь завершается успешно только тогда, когда готовы и отправитель, и получатель.\
>Буферезованный заблокирует пишущую горутину только при полном буфере.\
>Для читателя вроде без разницы, его блокируют при пустом канале.

5. Какой размер у структуры struct{}{}?
>Ответ:\
>Sizeof говорит что 0

6. Есть ли в Go перегрузка методов или операторов?
>Ответ:
>Go не поддерживает перегрузку функций и не поддерживает определяемые пользователем операторы.

7. В какой последовательности будут выведены элементы map[int]int?
   Пример:

```go
m[0]=1
m[1]=124
m[2]=281
```
>Ответ:
>с `map` нельзя пологаться на последовательность.

8. В чем разница make и new?
>Ответ:\
>`new` не инициализирует память, а только обнуляет ее. Он возвращает указатель на вновь выделенное нулевое значение. 
>`make` создает только срезы, карты и каналы и возвращает их инициализированными.

9. Сколько существует способов задать переменную типа slice или map?
```Go
var s0 []byte
s1 := []byte{}
s2 := make([]byte, 0)
s3 := new([]byte)
```

10. Что выведет данная программа и почему?

```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
>Ответ:
>1 1
>`p = &b` меняется не значение по указателю, а значение самого указателя, которое остаётся в локальной видимости.

11. Что выведет данная программа и почему?

```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```
>Ответ:
>0-4 в неизвестном порядке
>`wg.Done()` не сработает и до `fmt.Println("exit")` не дойдет потому что `wg` передан по значению, а не указатель на него.

12. Что выведет данная программа и почему?

```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
>Ответ:
>0
>n++ инкрементирует локальную переменную в блоке if

13. Что выведет данная программа и почему?

```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```
>Ответ:
>[100 2 3 4 5]
>У переменной а капасити 5.

14. Что выведет данная программа и почему?

```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}

```
>Ответ:
>[b b a][a a]
>в анонимной функции после append `slice[0] = "b"` мутирует уже другой слайс

